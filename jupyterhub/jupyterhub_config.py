import docker
import os
import sys
import logging
import re

from escapism import unescape
from ltiauthenticator.lti13.auth import LTI13Authenticator
from tornado.web import HTTPError

logger = logging.getLogger(__name__)


c = get_config()
docker_client = docker.from_env()

# ======================================================================================================================
# General config
#

# Binding
c.JupyterHub.hub_ip = ''
# proxy route entry to jupyterhub
c.JupyterHub.base_url = ''
#c.JupyterHub.bind_url = 'https://jupyterhub_proxy:8000/jupyter'

c.JupyterHub.spawner_class = 'dockerspawner.DockerSpawner'

# Proxy
c.ConfigurableHTTPProxy.api_url = 'http://jupyterhub_proxy:8001'
c.ConfigurableHTTPProxy.auth_token = os.environ.get('CONFIGPROXY_AUTH_TOKEN')
c.ConfigurableHTTPProxy.should_start = False
# c.ConfigurableHTTPProxy.debug = True
# c.ConfigurableHTTPProxy.log_level = 'DEBUG'

# Cleanups
# do not stop/remove any running servers when jupyterhub shuts down or restarts
c.JupyterHub.cleanup_servers = False

c.JupyterHub.shutdown_on_logout = True

# Debugging
# c.Application.log_level = 'DEBUG'
# c.JupyterHub.log_level = 'DEBUG'


# ======================================================================================================================
# Database
#

c.JupyterHub.db_url = 'postgresql://{}:{}@jupyterhub_db:5432/{}'.format(
    os.environ['POSTGRES_USER'],
    os.environ['POSTGRES_PASSWORD'],
    os.environ['POSTGRES_DB']
)

# ======================================================================================================================
# Spawner config
#

c.DockerSpawner.image = os.environ.get('DOCKER_NOTEBOOK_IMAGE', c.DockerSpawner.image)
c.DockerSpawner.network_name = os.environ.get('DOCKER_NETWORK_NAME', c.DockerSpawner.network_name)

notebook_dir = os.environ.get('DOCKER_NOTEBOOK_DIR', '/home/jovyan/work')
c.DockerSpawner.notebook_dir = notebook_dir
c.DockerSpawner.volumes = {'jupyter_user_{safe_username}': notebook_dir}

c.DockerSpawner.name_template = 'jupyter_user_{safe_username}'

# Remove containers once they are stopped
c.DockerSpawner.remove = True

# Debugging. Single-user server debug logging.
# c.DockerSpawner.debug = True
# c.Spawner.debug = True

c.Spawner.default_url = '/lab'  # '/notebooks' for classic view or '/lab' for JupyterLab view
c.Spawner.mem_limit = '1G'

# Environment.
c.Spawner.environment.update({"JUPYTERHUB_ALLOW_TOKEN_IN_URL": "1"})


# ======================================================================================================================
# Authenticator
#

c.Authenticator.admin_users = {'admin'}
c.Authenticator.any_allow_config = True
c.Authenticator.allow_all = True


c.MultiAuthenticator.authenticators = [
    (LTI13Authenticator, '<name of your 1st ILIAS instance>', {
        'issuer': 'https://ilias1.example.tld',
        'authorize_url': 'https://ilias1.example.tld/Modules/LTIConsumer/ltiauth.php',
        'jwks_endpoint': 'https://ilias1.example.tld/Modules/LTIConsumer/lticerts.php',
        'client_id': '<ID generated by ILIAS>',
        'oauth_callback_url': 'https://jupyterhub.example.tld:8000/hub/<name of your 1st ILIAS instance>/lti13/oauth_callback',
        'enable_auth_state': True
    }),
    (LTI13Authenticator, '<name of your 2nd ILIAS instance>', {
        'issuer': 'https://ilias2.example.tld',
        'authorize_url': 'https://ilias2.example.tld/Modules/LTIConsumer/ltiauth.php',
        'jwks_endpoint': 'https://ilias2.example.tld/Modules/LTIConsumer/lticerts.php',
        'client_id': '<ID generated by ILIAS>',
        'oauth_callback_url': 'https://jupyterhub.example.tld:8000/hub/<name of your 2st ILIAS instance>/lti13/oauth_callback',
        'enable_auth_state': True
    })
]

c.JupyterHub.authenticator_class = 'multiauthenticator.multiauthenticator.MultiAuthenticator'


# ----------------------------------------------------------------------------------------------------------------------
# Authentication state hook
#


def auth_state_spawner_hook(spawner, auth_state):
    if not auth_state:
        return

    # Data extraction
    roles_data_list = auth_state['https://purl.imsglobal.org/spec/lti/claim/roles']
    tool_platform_data = auth_state['https://purl.imsglobal.org/spec/lti/claim/tool_platform']
    context_data = auth_state['https://purl.imsglobal.org/spec/lti/claim/context']
    resource_link_data = auth_state['https://purl.imsglobal.org/spec/lti/claim/resource_link']
    custom_data = auth_state.get("https://purl.imsglobal.org/spec/lti/claim/custom", {})

    username = spawner.template_namespace().get('username')
    client_id = auth_state['aud']
    platform_id = tool_platform_data['guid']
    course_id = context_data['id']
    link_id = resource_link_data['id']

    # Determine instructor access
    instructor_access = False
    for role in roles_data_list:
        if str(role.split('#')[-1]).lower() in ['administrator', 'instructor']:
            instructor_access = True

    if ('ONLINE' not in custom_data or custom_data['ONLINE'].lower() != 'true') and not instructor_access:
        # The LTI object is not online for students. Abort spawning.
        raise HTTPError(500, reason="LTI object resources are offline. "
                                    "Please contact your instructor or course administrator.")

    if instructor_access:
        spawner.notebook_dir = '/home/jovyan/'
        spawner.environment['INSTRUCTOR_ACCESS'] = 'true'
        spawner.environment['GRANT_SUDO'] = '1'
        spawner.environment['UID'] = '0'
        spawner.extra_create_kwargs = {'user': 'root'}

    #
    # Volumes
    #

    # Instructor's LTI object volume. Extra volume per LTI object shared by instructor role.
    inst_volume_name = f"jupyter_lti_object_{client_id}_{course_id}_{link_id}"
    mode = 'rw' if instructor_access else 'ro'
    spawner.volumes.update({inst_volume_name: {'bind': '/home/jovyan/__shared', 'mode': mode}})

    # Course-scoped metadata volume
    spawner.volumes.update({f"jupyter_lti_metadata_{client_id}_{course_id}": {'bind': '/data/metadata', 'mode': 'rw'}})

    stud_submission_volume_partial_name = f"jupyter_lti_stud_submission_{client_id}_{course_id}_"

    if not instructor_access:
        # Student submission volume for the entire course which student solutions are pushed to by the system.
        # Readonly to students for solution insights. TODO: switch mode to 'ro'
        spawner.volumes.update({stud_submission_volume_partial_name + f"{username}": {'bind': '/home/jovyan/work/__submission', 'mode': 'rw'}})

    if instructor_access:
        # List submission volumes and corresponding users for this specific course
        stud_submission_volume_regex = f"{stud_submission_volume_partial_name}(.*)"
        stud_submission_volumes = list(filter(
            re.compile(stud_submission_volume_regex).match, [v.name for v in docker_client.volumes.list()]
        ))
        stud_submission_users = list()
        for av in stud_submission_volumes:
            stud_submission_volume_user = unescape(re.search(stud_submission_volume_regex, av).group(1), '-')
            stud_submission_users.append(stud_submission_volume_user)
        # Mount submission volumes for this specific course
        for u, v in zip(stud_submission_users, stud_submission_volumes):
            spawner.volumes.update({v: {'bind': f'/home/jovyan/__submissions/{u}', 'mode': 'ro'}})

    resource_local_path = f"{context_data['title']}/{resource_link_data['title']} (RID-{course_id}-{link_id})"
    spawner.environment['RESOURCE_LOCAL_PATH'] = resource_local_path
    spawner.default_url = '' if instructor_access else f'/lab/tree/{resource_local_path}'


    #
    # Custom selection of the user server image
    #
    if 'USER_SERVER_IMAGE' in custom_data:
        logger.info("Setting user server image '%s' from LTI custom field...", custom_data['USER_SERVER_IMAGE'])
        spawner.image = custom_data['USER_SERVER_IMAGE']
    else:
        logger.info('Setting default user server image...')
        spawner.image = os.environ.get('DOCKER_NOTEBOOK_IMAGE', c.DockerSpawner.image)

    #
    # Git
    #
    if 'STARTUP_GIT_REPOSITORY' in custom_data:
        logger.info("Setting the startup Git repository to '%s'...", custom_data['STARTUP_GIT_REPOSITORY'])
        spawner.environment['STARTUP_GIT_REPOSITORY'] = custom_data['STARTUP_GIT_REPOSITORY']

        if 'STARTUP_GIT_REPOSITORY_DIR_NAME' in custom_data:
            spawner.environment['STARTUP_GIT_REPOSITORY_DIR_NAME'] = custom_data['STARTUP_GIT_REPOSITORY_DIR_NAME']

    # Always start with the custom user server startup script
    spawner.cmd = ['custom_user_server_startup']

c.DockerSpawner.auth_state_hook = auth_state_spawner_hook


# ======================================================================================================================
# Services and roles
#

c.JupyterHub.services = [
    {
        "name": "jupyterhub-idle-culler-service",
        "command": [
            sys.executable, "-m", "jupyterhub_idle_culler", "--timeout=360", "--cull-users"
        ]
    }
]

# Get service admin users and tokens from env variable.
admin_services_env = os.environ.get('JPY_ADMIN_SERVICES')
admin_services = [(sa.split(':')[0], sa.split(':')[1]) for sa in admin_services_env.split(';')]

# Register admin services
c.JupyterHub.services.extend([{'name': admin_service[0]} for admin_service in admin_services])

# Define additional tokens for existing services.
c.JupyterHub.service_tokens = {}

for admin_service in admin_services:
    c.JupyterHub.service_tokens[admin_service[1]] = admin_service[0]

c.JupyterHub.load_roles = [
    {
        'name': 'service-role',
        'scopes': [
            'access:servers',
            'admin:users',
            'admin:servers',
            'delete:users',
            'delete:servers',
            'servers',
            'tokens'
        ],
        'services': [admin_service[0] for admin_service in admin_services]
    },
    {
        "name": "jupyterhub-idle-culler-role",
        "scopes": [
            "list:users",
            "read:users:activity",
            "read:servers",
            "delete:servers",
            "delete:users"
        ],
        # assignment of role's permissions to:
        "services": [
            "jupyterhub-idle-culler-service"
        ]
    }
]
